package edu.ucla.astro.irlab.io;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
/**
 *	@author Ji Man Sohn @ UCLA Infrared Laboratory
 *	Command class holds structure of a command used in JSON configuration 
 */
public class Command {
	/** Name(key) of the command that can be called for verification */
	private String name;					
	/** Command string with parameters place-holders that will be passed on to device [ex: (p1) (p2) cmd (p3) (p4)] */
	private String command;
	/** Regular expression of response with parameter placeholders */
	private String responseFormat;
	/** Description of the command that can be used for user experience */ 
	private String description;					
	
	/** Regular expression for the successful response. It will be auto-generated by Commander using responseFormat.*/
	private transient String happyRegex;
	/** Regular expression for error, unsuccessful response. It will be auto-generated by Commander using deviceSadRegex of Commander.*/
	private String sadRegex;	
	/** List of argument parameters that is auto-generated upon the first query*/
	private transient ArrayList<String> paramList;
	/** List of response parameters that is auto-generated upon the first query*/
	private transient ArrayList<String> responseList;
	
	/**
	 * Returns the name(key) of the Command in String
	 * @return name(key) of the Command
	 */
	public String getName() {
		return name;
	}
	/**
	 * Returns command structure that will be sent to the hardware. 
	 * This structure contains place-holders for parameters that will be replace with actual values.
	 * @return command structure with parameter place-holders
	 */
	public String getCommand() {
		return command;
	}
	/**
	 * Returns successful response structure expected from the hardware.
	 * @return repsone structure
	 */
	public String getResponseFormat() {return responseFormat;}
	/**
	 * Return description of the command 
	 * @return command description
	 */
	public String getDescription() {return description;}	
	/**
	 * Allows commander to set happy regular expression using regular expression depends on parameter type.
	 * @param Regular expression of the command for successful response
	 */
	public void setHappyRegex(String happy) {
		happyRegex = happy;
	}
	/**
	 * Returns regular expression for successful response of the command
	 * @return happy regular expression
	 */
	public String getHappyRegex() {
		return happyRegex;
	}
	/**
	 * Allows commander to set sad regular expression using regular expression depends on parameter type.
	 * @param Regular expression of the command for unsuccessful response
	 */
	public void setSadRegex(String sad) {
		sadRegex = sad;
	}
	/**
	 * Returns regular expression for unsuccessful response of the command
	 * @return sad regular expression
	 */
	public String getSadRegex() {
		return sadRegex;
	}
	/**
	 * Returns boolean indicating if this command is request type or not by existence of responseFormat
	 * @return request indicator
	 */
	public boolean isRequest() {
		if (responseFormat != null) { return true; }
		else { return false; }
	}
	/**
	 * Generates argument parameter list from Command
	 * It goes through command field for place-holder for parameter and add it's key to the list.
	 */
	private void makeParamKeyList() {
		Pattern pattern = Pattern.compile("(\\(\\S*?\\))");
		Matcher matcher = pattern.matcher(command);
		
		paramList = new ArrayList<String>();
		
		while(matcher.find()) {
			String found = matcher.group();
			paramList.add(found.replace("(","").replace(")",""));
		}
	}
	/**
	 * Returns paramList. If it's not set yet, it generates paramList before returning.
	 * @return paramList
	 */
	public ArrayList<String> getParamKeyList() {
		if (paramList == null) {
			makeParamKeyList();
		}
		return paramList;
	}
	/**
	 * Generates response parameter list from Command
	 * It goes through responseFormat field for place-holder for parameter and add it's key to the list.
	 */
	private void makeResponseList() {
		if (responseFormat != null) {
			Pattern pattern = Pattern.compile("(\\(\\S*?\\))");
			Matcher matcher = pattern.matcher(responseFormat);
			
			responseList = new ArrayList<String>();
			
			while(matcher.find()) {
				String found = matcher.group();
				responseList.add(found.replace("(","").replace(")",""));
			}
		} else {
			responseList = new ArrayList<String>();
		}
	}
	/**
	 * Returns responseList. If it's not set yet, it generates paramList before returning.
	 * @return responseList
	 */
	public ArrayList<String> getResponseList() {
		if (!isRequest()) {
			return new ArrayList<String>();
		} else if (responseList == null) {
			makeResponseList();
		}
		return responseList;
	}
	/**
	 * Using HashMap of parameters, it checks paramKeyList and responseList to see if the Commander knows all of this Command's Parameter.
	 * @param HasmMap of parameters to be checked against.
	 * @throws InvalidConfigurationException
	 */
	public void validate(HashMap<String,ParameterDefinition> pMap) throws InvalidConfigurationException{
		//TODO complete method
		makeParamKeyList();
		makeResponseList();
		
		for (String s : paramList) {
			if (!pMap.containsKey(s) && !Commander.defaultParamDefMap.containsKey(s)) {
				 throw new InvalidConfigurationException("Invalid Configuration : unknown parameter\"" + s +"\" required in command \"" + name + "\".");
			}
		}
		for (String s : responseList) {
			if (!pMap.containsKey(s) && !Commander.defaultParamDefMap.containsKey(s)) {
				 throw new InvalidConfigurationException("Invalid Configuration : unknown parameter\"" + s +"\" expected in command \"" + name + "\".");
			}
		}
		
	}
	/**
	 * Returns String description of the Command with name and argument parameters(if exist)
	 */
	public String toString(){
		String out = "Command: " + name;
		if (getDescription() != null){
			out += "\n" + getDescription();
		}
		if(getParamKeyList().size() > 0){
			out += "\nParameters : " + getParamKeyList().toString();
		}
		return out;
	}
}
